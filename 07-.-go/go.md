# Go 스케줄러

## 스케줄러

스케줄링이란 무엇일까요? 사전적 의미로는 여러 프로세스가 번갈아가며 사용하는 자원을 어떤 프로세스에게 자원을 할당할지 결정하는것인데요. Go 에서는 고루틴이 사용하는 자원에 해당하게 되겠네요.

Go 런타임이 사용하는 스케줄러를 Go 스케줄러라고 하고, Go 스케줄러는 m:n 스케줄링이란 기법을 사용하는데요, 사실 m:n 스케줄링이라 해도 비교할 대상이 없으면 이해하기 어렵습니다. 비교할 대상들을 한번 보겠습니다.

* 1:1 스케줄링 (닷넷, java...)
  * 각 사용자 수준 스레드가 하나의 커널 스레드로 매핑
  * 사용자와 OS가 다수의 스레드를 생성합니다.
  * 사용자가 생성한 각각의 스레드가 운영 체제에서 직접적으로 관리
* M:N 스케줄링 (Go Runtime이 제어)
  * 각 사용자 수준스레드가 다수의 커널 스레드로 사상
  * 사용자 수준(런타임)의 스레드 스케줄러가 필요.

<알림>

고에서는 아래와 스레드가 관리됩니다.

* 고루틴
  * Go 런타임에 의해 관리되는 경량화 스레드 입니다.
* 사용자 수준 스레드
  * 런타임 라이브러리(사용자)에 의해 관리되는 스레드 입니다.
* 커널 수준 스레드
  * 생성 주체가 커널이고, OS에 의해 관리되는 스레드 입니다. <종료>

참고 자료

* [https://helloinyong.tistory.com/293](https://helloinyong.tistory.com/293)
* [https://velog.io/@taehee-kim-dev/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BB%A4%EB%84%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C](https://velog.io/@taehee-kim-dev/%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C-%EC%BB%A4%EB%84%90-%EC%88%98%EC%A4%80-%EC%8A%A4%EB%A0%88%EB%93%9C)

## 포크 - 조인 동시성

동시성을 이해하기 위해서 몇가지 패턴을 알아봅시다.

* 분할-정복 패턴
  * 문제를 재귀적인 패턴으로 분할한 다음 결과를 조합합니다. 순차적인 방식으로 동작합니다.
* 맵리듀스
  * 맵으로 데이터를 분할하고, 각 조각에 대해 함수를 적용한 후 중간결과를 집계합니다. 이는 병렬로 실행 가능합니다.
* 파이프라인
  * 작업을 여러 단계로 나누고, 각 단계를 병렬로 실행합니다. 한 단계의 결과가 다음 단계의 입력으로 전달합니다.
* 업다운 방식
  * 하나의 보스 스레드가 작업을 분배하고, 작업자 프로세스나 프로세스가 할당된 작업을 처리합니다. 보스 스레드는 반드시 대기하지 않고 다른 작업을 진행할 수 있습니다.

Go는 fork-join 모델이라는 동시성 모델을 따르고 있습니다. 임의의 시점에 자식 분기를 만들어 부모와 동일하게 실행해 나가고 미래의 어느 시점에 부모와 자식 분기가 합류하여 하나로 합쳐지는 형태입니다.



<figure><img src="../.gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

일반적으로 sync.Wait() 구문을 사용하여 합쳐집니다.

참고 자료

* [https://velog.io/@cafefarm-johnny/concurrency-component](https://velog.io/@cafefarm-johnny/concurrency-component)

## 균등 스케줄링 전략

스케줄링에는 다음과 같은 전략들이 있습니다.

* 순환 스케줄링
  * 각 프로세스에 동일한 양의 CPU 시간을 할당합니다. 프로세스는 도착 순서대로 대기열에 들어가며, 할당된 시간만큼 CPU를 사용한 후에는 다음 프로세스로 넘어갑니다.
* 우선순위 스케줄링
  * 각 프로세스에 우선순위를 부여하여 CPU를 할당합니다. 높은 우선순위를 가진 프로세스가 낮은 우선순위를 가진 프로세스보다 더 많은 CPU 시간을 할당받습니다.
* 멀티레벨 큐 스케줄링
  * 프로세스를 여러 개의 큐로 분할하여 각 큐에 다른 우선순위를 부여합니다. 다양한 우선순위에 따라 각 큐에서 프로세스가 처리됩니다.
* 가장 짧은 작업 우선 스케줄링
  * 대기 중인 프로세스 중에서 실행 시간이 가장 짧은 작업을 가장 먼저 처리합니다. 이 방식은 평균 대기 시간을 최소화하는 데 효과적입니다.
* 가장 짧은 남은 시간 우선 스케줄링
  * 이 방식은 현재 실행 중인 프로세스의 남은 실행 시간이 가장 짧은 프로세스에 CPU를 할당합니다. 선점형 스케줄링 방식으로, 새로운 프로세스가 도착하면 현재 실행 중인 프로세스보다 더 짧은 실행 시간이 있는 경우 CPU를 뺏을 수 있습니다.

Go 런타임은 균등 스케줄링 전략 + 작업 훔치기 전략을 사용하는데요, 모든 부하를 현재 사용할 수 있는 프로세서로 고르게 나눈 다음. 충분히 활용하지 않고 있는 논리적인 프로세서에게 줄 작업을 다른 프로세서에게 훔쳐줍니다. 이때 스톨링 조인(스레드의 실행을 멈추고 다른 작업을 찾음)이 발생합니다.

* [https://rakyll.org/scheduler/](https://rakyll.org/scheduler/)
* [https://marsettler.com/posts/2018-10-13-go-work-stealing-scheduler/](https://marsettler.com/posts/2018-10-13-go-work-stealing-scheduler/)



## 동시성과 병렬성

### **동시성**

* 동시성은 여러 작업이 동시에 실행되는 것처럼 보이는 개념을 의미합니다. 하지만 실제로는 단일 프로세서에서 여러 작업이 번갈아가면서 조각조각 실행되는 것입니다. 즉, 여러 작업이 동시에 시작되고 실행되지만, 동시에 실행되는 것은 아닙니다. 동시성은 주로 다음과 같은 상황에서 유용합니다:
  * 멀티태스킹: 여러 작업이 동시에 실행되는 것처럼 보이게 합니다.
  * 이벤트 처리: 여러 이벤트를 동시에 처리하거나 병렬로 처리합니다.
  * 멀티스레딩: 여러 스레드가 동시에 실행되는 것처럼 보이게 합니다.

### **병렬성**

* 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 의미합니다. 이는 여러 개의 프로세서 또는 코어를 사용하여 작업을 동시에 처리함으로써 가능합니다. 병렬성은 하나의 작업을 여러 부분으로 나누고 각 부분을 별도의 프로세서에서 동시에 실행하여 전체 작업을 가속화합니다. 병렬성은 대규모 데이터 처리, 고성능 컴퓨팅, 그래픽 처리 등에 유용합니다.
* [https://velog.io/@kwontae1313/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4](https://velog.io/@kwontae1313/%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B0%A8%EC%9D%B4)
* [https://seamless.tistory.com/42](https://seamless.tistory.com/42)





